.model small
.stack 100h

.data
    buffer db 81 dup(?)        ; Буфер для зберігання введення (80 байт + 1 для нуль-термінатора)
    lineCount dw 0             ; Лічильник кількості рядків, зчитаних з введення
    outputCount dw 0           ; Лічильник кількості виведених рядків
    keys dw 10000 dup(?)       ; Масив для зберігання ключів (максимум 10000 слів)
    values dw 10000 dup(?)     ; Масив для зберігання значень (максимум 10000 слів)

.code
main proc
    mov ax, @data
    mov ds, ax

    mov cx, 0  ; Ініціалізація лічильника рядків

read_loop:
    ; Перевірка, чи виведено вже 1000 рядків
    mov ax, [outputCount]
    cmp ax, 1000
    je ending

    ; Зчитування рядка зі стандартного вводу
    mov ah, 3Fh
    mov bx, 0
    lea dx, buffer
    mov cx, 80h
    int 21h

    cmp ax, cx
    jae checking_eof
    mov cx, ax

    inc word ptr [lineCount]

    ; Обробка рядка для виділення ключів та значень
    mov si, offset buffer  ; Встановлення SI на початок буфера

    ; Виклик підпрограми для розділення рядка на масиви ключів та значень
    call separate_keys_and_values
     ; Виклик підпрограми для обчислення суми та середнього арифметичного для кожного ключа
    call calculate_sum_and_average


    ; Перевірка на кінець файлу
    jmp read_loop

checking_eof:
    ; Перевірка на кінець файлу
    mov ah, 3Eh
    mov bx, 0
    lea dx, buffer
    mov cx, 1
    int 21h

    ; Якщо кінець файлу не досягнуто, продовжуємо обробку
    cmp ax, 0
    jne read_loop

    ; Якщо досягнуто кінця файлу, завершуємо програму
    jmp ending

ending:
    ; Завершення програми
    mov ax, 4C00h
    int 21h

separate_keys_and_values proc
    ; Підпрограма для розділення рядка на масиви ключів та значень
    ; Роздільник - пробіл
    

    mov di, offset keys    ; Встановлення DI на початок масиву ключів
    mov bx, offset values  ; Встановлення BX на початок масиву значень

next_word:
    ; Пропуск пробілів
    mov al, [si]
    cmp al, ' '            ; Перевірка, чи поточний символ - пробіл
    je skip_space          ; Якщо так, пропускаємо пробіл
    inc si                 ; Перехід до наступного символу
    loop next_word         ; Повторення, поки CX != 0

skip_space:
    ; Збереження ключа
    mov ah, 0              ; Очищення AH
    mov al, [si]           ; Завантаження символу з буфера
    mov [di], al           ; Збереження символу в масиві ключів
    inc si                 ; Перехід до наступного символу
    inc di                 ; Перехід до наступної позиції в масиві ключів

    ; Збереження значення
    mov al, [si]           ; Завантаження символу з буфера
    mov [bx], al           ; Збереження символу в масиві значень
    inc si                 ; Перехід до наступої позиції в буфері
    inc bx                 ; Перехід до наступної позиції в масиві значень

    ; Перевірка кінця рядка
    cmp al, 0              ; Перевірка, чи це кінець рядка
    je end_of_line         ; Якщо так, завершуємо обробку рядка
    jmp next_word          ; В іншому випадку переходимо до наступного слова

end_of_line:
    ret                    ; Повернення з підпрограми
separate_keys_and_values endp

main endp
end main
calculate_sum_and_average proc
    ; Підпрограма для обчислення суми та середнього арифметичного для кожного ключа

    ; Ініціалізація змінних
    mov  cx, lineCount            ; Завантаження кількості рядків у CX
    mov  si, offset keys          ; Завантаження адреси початку масиву ключів у SI

calculate_sum_and_average_loop:
    ; Цикл обчислення суми для кожного ключа
    mov  ax, 0                    ; Очищення AX (сума)
    mov  di, offset values        ; Завантаження адреси початку масиву значень у DI

    ; Внутрішній цикл для обчислення суми
    mov  bx, cx                   ; Завантаження кількості рядків у BX
    mov  dx, 0                    ; Очищення DX (кількість елементів)
    add  dx, bx                   ; Додавання кількості рядків до кількості елементів
    shl  dx, 1                    ; Помноження кількості елементів на 2 (розмір одного елементу у байтах)
    add  di, dx                   ; Перехід до відповідної позиції у масиві значень

calculate_sum:
    add  ax, [di]                 ; Додавання значення до суми
    sub  di, 2                    ; Переміщення до попереднього значення
    loop calculate_sum            ; Повторення цього для всіх значень

    ; Збереження суми у відповідний елемент масиву ключів
    mov  [si + 2], ax             ; Збереження суми для поточного ключа
    add  si, 4                    ; Перехід до наступного ключа та слоту для середнього значення
    loop calculate_sum_and_average_loop  ; Повторення для наступного ключа
    ret                           ; Повернення з підпрограми
calculate_sum_and_average endp
